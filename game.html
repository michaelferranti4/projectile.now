<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8" />
    <title>Desert Cab Dash</title>
    <link rel="stylesheet" href="game.css" />

    <!-- Brython runtime/stdlib -->
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython.min.js"
    ></script>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/brython@3.11.3/brython_stdlib.js"
    ></script>

    <style>
      /* No debug box—canvas can occupy full height */
      body {
        margin: 0;
        padding: 0;
      }
      #gameCanvas {
        display: block;
        margin: 0 auto;
      }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

  </head>

  <body onload="brython()">
    <!-- Overlay shown until user starts the game -->
    <div
      id="start-overlay"
      style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
        color: #fff;
        z-index: 2;
      "
    >
      <button id="start-btn" style="font-size: 24px; padding: 10px 20px;">
        Start Game
      </button>
    </div>

    <!-- Background music: local file “cab.mp3” -->
    <audio id="bg-music" src="cab.mp3" loop preload="auto"></audio>

    <!-- Canvas for the game -->
    <canvas id="gameCanvas" width="800" height="900"></canvas>


    <!-- The Python game logic (Brython) -->
    <script type="text/python" src="game.py"></script>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const PLAYER_MOVE_STEP = 20;
      const DESERT_WIDTH     = 80;
      const BOTTOM_MARGIN    = 10;
      const startBtn = document.getElementById('start-btn');
      const music = document.getElementById('bg-music');

      startBtn.addEventListener('click', () => {
        // Play audio on click (synchronous user gesture)
        music.play().catch(() => {
          // If direct play() is blocked, do muted fallback
          music.muted = true;
          music
            .play()
            .then(() => {
              music.currentTime = 0;
              music.muted = false;
              return music.play();
            })
            .catch(() => {});
        });

        if (window.start_game) {
          window.start_game();
        }
        document.getElementById('start-overlay').style.display = 'none';
      });
       if ('ontouchstart' in window) {
        const touch_target = { x: null, y: null };
        window.touch_target = touch_target;
        const TOUCH_MAX_SPEED = PLAYER_MOVE_STEP * 2;

        // update() loop: nudge the cab toward touch_target
        function handleTouchMovement() {
          if (touch_target.x === null) return;

          // get the on-screen size & position of the canvas
          const rect = canvas.getBoundingClientRect();
          // compute how much CSS pixels map to one canvas pixel
          const scaleX = canvas.width  / rect.width;
          const scaleY = canvas.height / rect.height;

          // translate the touch into canvas space
          const touchX = (touch_target.x - rect.left) * scaleX;
          const touchY = (touch_target.y - rect.top) * scaleY;

          // compute the center of the cab in canvas space
          const cabCenterX = player_x + PLAYER_WIDTH  / 2;
          const cabCenterY = player_y + PLAYER_HEIGHT / 2;

          // vector toward the touch
          let dx = touchX - cabCenterX;
          let dy = touchY - cabCenterY;
          const dist = Math.hypot(dx, dy);
          if (dist > 1) {
            // move at a fixed speed toward the target
            const speed = TOUCH_MAX_SPEED;
            player_x += (dx / dist) * speed;
            player_y += (dy / dist) * speed;
            // clamp to road bounds
            player_x = Math.max(DESERT_WIDTH,
                         Math.min(player_x, WIDTH - DESERT_WIDTH - PLAYER_WIDTH));
            player_y = Math.max(0,
                         Math.min(player_y, HEIGHT - PLAYER_HEIGHT - BOTTOM_MARGIN));
          }
        }

        // Hook it into your game‐loop just before move‐entities:


        // Track finger position
        canvas.addEventListener("touchstart", e => {
          e.preventDefault();
          const t = e.changedTouches[0];
          touch_target.x = t.clientX;
          touch_target.y = t.clientY;
        }, { passive: false });

        canvas.addEventListener("touchmove", e => {
          e.preventDefault();
          const t = e.changedTouches[0];
          touch_target.x = t.clientX;
          touch_target.y = t.clientY;
        }, { passive: false });

        canvas.addEventListener("touchend", e => {
          e.preventDefault();
          touch_target.x = touch_target.y = null;
        }, { passive: false });
      }

    </script>
  </body>
</html>


